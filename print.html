<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>microvm.nix</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="declaring.html"><strong aria-hidden="true">2.</strong> Declaring MicroVMs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="options.html"><strong aria-hidden="true">2.1.</strong> Configuration options</a></li><li class="chapter-item expanded "><a href="interfaces.html"><strong aria-hidden="true">2.2.</strong> Network interfaces</a></li><li class="chapter-item expanded "><a href="shares.html"><strong aria-hidden="true">2.3.</strong> Shared directories</a></li><li class="chapter-item expanded "><a href="output-options.html"><strong aria-hidden="true">2.4.</strong> Output options</a></li><li class="chapter-item expanded "><a href="microvm-options.html"><strong aria-hidden="true">2.5.</strong> Options reference</a></li></ol></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">3.</strong> Running a MicroVM as a package</a></li><li class="chapter-item expanded "><a href="host.html"><strong aria-hidden="true">4.</strong> Preparing a host for declarative MicroVMs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simple-network.html"><strong aria-hidden="true">4.1.</strong> A simple network setup</a></li><li class="chapter-item expanded "><a href="host-systemd.html"><strong aria-hidden="true">4.2.</strong> Host systemd services</a></li></ol></li><li class="chapter-item expanded "><a href="declarative.html"><strong aria-hidden="true">5.</strong> Declarative MicroVMs</a></li><li class="chapter-item expanded "><a href="microvm-command.html"><strong aria-hidden="true">6.</strong> Imperative MicroVM management</a></li><li class="chapter-item expanded "><a href="conventions.html"><strong aria-hidden="true">7.</strong> Conventions</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">8.</strong> Frequently Asked Questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">microvm.nix</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p><strong>microvm.nix</strong> is a Flake to run lightweight NixOS virtual machines
on NixOS. Starting with the reasons why for the remainder of this
chapter, this handbook guides you through the provisioning of MicroVMs
on your NixOS machine.</p>
<h2 id="compartmentalization"><a class="header" href="#compartmentalization">Compartmentalization</a></h2>
<p>NixOS makes running services a breeze. Being able to quickly rollback
configuration is a life-saver. Not so much however on systems that are
shared by multiple services where maintenance of one affects others.</p>
<p>Increase stability by partitioning services into virtual NixOS systems
that can be updated individually.</p>
<h2 id="the-case-against-containers"><a class="header" href="#the-case-against-containers">The Case Against Containers</a></h2>
<p>Linux containers are not a single technology but a plethora of kernel
features that serve to isolate various system resources so that the
running system appears as one. It is still one shared Linux kernel
with a huge attack surface.</p>
<p>Virtual machines on the other hand run their own OS kernel, reducing
the attack surface to the hypervisor and its device drivers. The
resource usage however incurs some overhead when compared with
containers, with memory allocation being especially inflexible.</p>
<p><strong>microvm.nix</strong> ships an additional security feature: the root
filesystem is a read-only squashfs that includes only the binaries of
your configuration. That of course holds only true unless you mount the
host's /nix/store as a share for faster build times, or mount the
store with a writable overlay.</p>
<h2 id="just-virtual-machines"><a class="header" href="#just-virtual-machines">Just Virtual Machines?</a></h2>
<p>Full virtualization has been available for a long time with QEMU and
VirtualBox. The <em>MicroVM</em> movement wants to express that
virtualization overhead has been reduced a lot by replacing emulated
devices with <em>virtio</em> interfaces that have been optimized for an
emulated environment.</p>
<p>This Flake offers you to run your MicroVMs not only on QEMU but with
other Hypervisors that have been explicitly authored for
<em>virtio</em>. Some of them are written in Rust, a programming language
that is renowned for being safer than C.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-nixos-microvms"><a class="header" href="#declaring-nixos-microvms">Declaring NixOS MicroVMs</a></h1>
<p><img src="demo.gif" alt="Demo" /></p>
<p>microvm.nix creates virtual machine disk images and runner script
packages for the entries of the <code>nixosConfigurations</code> section of a
<code>flake.nix</code> file.</p>
<h2 id="the-microvm-module"><a class="header" href="#the-microvm-module">The <code>microvm</code> module</a></h2>
<p>To add MicroVM functionality, a NixOS system configuration is
augmented by importing this flake's <code>nixosModule.microvm</code>:</p>
<pre><code class="language-nix"># Example flake.nix
{
  inputs.nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
  inputs.microvm.url = &quot;github:astro/microvm.nix&quot;;
  inputs.microvm.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;

  outputs = { self, nixpkgs, microvm }: {
    # Example nixosConfigurations entry
    nixosConfigurations.my-microvm = nixpkgs.lib.nixosSystem {
      system = &quot;x86_64-linux&quot;;
      modules = [
        # Include the microvm module
        microvm.nixosModules.microvm
        # Add more modules here
        {
          networking.hostName = &quot;my-microvm&quot;;
          microvm.hypervisor = &quot;cloud-hypervisor&quot;;
        }
      ];
    };
  };
}
</code></pre>
<p>To get you started quickly, a Flake template is included. Run <code>nix flake init -t github:astro/microvm.nix</code> in a new project directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-options"><a class="header" href="#configuration-options">Configuration options</a></h1>
<p>By including the <code>microvm</code> module a set of NixOS options is made
available for customization. These are the most important ones:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>microvm.hypervisor</code></td><td>Hypervisor to use by default in <code>microvm.declaredRunner</code></td></tr>
<tr><td><code>microvm.vcpu</code></td><td>Number of Virtual CPU cores</td></tr>
<tr><td><code>microvm.mem</code></td><td>RAM allocation in MB</td></tr>
<tr><td><code>microvm.interfaces</code></td><td>Network interfaces</td></tr>
<tr><td><code>microvm.volumes</code></td><td>Block device images</td></tr>
<tr><td><code>microvm.shares</code></td><td>Shared filesystem directories</td></tr>
<tr><td><code>microvm.devices</code></td><td>PCI/USB devices for host-to-vm passthrough</td></tr>
<tr><td><code>microvm.socket</code></td><td>Control socket for the Hypervisor so that a MicroVM can be shutdown cleanly</td></tr>
<tr><td><code>microvm.user</code></td><td>(qemu only) User account which Qemu will switch to when started as root</td></tr>
<tr><td><code>microvm.forwardPorts</code></td><td>(qemu user-networking only) TCP/UDP port forwarding</td></tr>
<tr><td><code>microvm.kernelParams</code></td><td>Like <code>boot.kernelParams</code> but will not end up in <code>system.build.toplevel</code>, saving you rebuilds</td></tr>
<tr><td><code>microvm.storeOnBootDisk</code></td><td>Enables the store on the boot squashfs even in the presence of a share with the host's <code>/nix/store</code></td></tr>
<tr><td><code>microvm.writableStoreOverlay</code></td><td>Optional string of the path where all writes to <code>/nix/store</code> should go to.</td></tr>
</tbody></table>
</div>
<p>See <a href="https://github.com/astro/microvm.nix/blob/main/nixos-modules/microvm/options.nix">the options declarations</a>
for a full reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-interfaces"><a class="header" href="#network-interfaces">Network interfaces</a></h1>
<p>Declare a MicroVM's virtual network interfaces like this in its NixOS
configuration:</p>
<pre><code class="language-nix">{
  microvm.interfaces = [ {
    type = &quot;tap&quot;;

    # interface name on the host
    id = &quot;microvm-a1&quot;;

    # Ethernet address of the MicroVM's interface, not the host's
    #
    # Locally administered have one of 2/6/A/E in the second nibble.
    mac = &quot;02:00:00:00:00:01&quot;;
  } ];
}
</code></pre>
<h2 id="type--user"><a class="header" href="#type--user"><code>type = &quot;user&quot;</code></a></h2>
<p>User-mode networking is only provided by qemu and kvmtool, providing
outgoing connectivity to your MicroVM without any further setup.</p>
<p>As kvmtool seems to lack a built-in DHCP server, additional static IP
configuration is necessary inside the MicroVM.</p>
<h2 id="type--tap"><a class="header" href="#type--tap"><code>type = &quot;tap&quot;</code></a></h2>
<p>Use a virtual tuntap Ethernet interface. Its name is the value of
<code>id</code>.</p>
<p>Some Hypervisors may be able to automatically create these interfaces
when running as root, which we advise against. Instead, create the
interfaces before starting a MicroVM:</p>
<pre><code class="language-bash">sudo ip tuntap add $IFACE_NAME mode tap user $USER
</code></pre>
<p>When running MicroVMs through the <code>host</code> module, the tap network
interfaces are created through a systemd service dependency.</p>
<h2 id="type--macvtap"><a class="header" href="#type--macvtap"><code>type = &quot;macvtap&quot;</code></a></h2>
<p><em>MACVTAP</em> interfaces attach to a host's physical network interface,
joining the same Ethernet segment with a separate MAC address.</p>
<p>Before running a MicroVM interactively from a package, do the
following steps manually:</p>
<pre><code class="language-bash"># Parent interface:
LINK=eth0
# MACVTAP interface, as specified under microvm.interfaces.*.id:
ID=microvm1
# Create the interface
sudo ip l add link $LINK name $ID type macvtap mode bridge
# Obtain the interface index number
IFINDEX=$(cat /sys/class/net/$ID/ifindex)
# Grant yourself permission
chown $USER /dev/tap$IFINDEX
</code></pre>
<p>When running MicroVMs through the <code>host</code> module, the macvtap network
interfaces are created through a systemd service dependency. Per
interface with <code>type = &quot;macvtap&quot;</code>, a <code>link</code> attribute with the parent
interface, and <code>mode</code> attribute for the MACVTAP filtering mode must be
specified.</p>
<h2 id="type--bridge"><a class="header" href="#type--bridge"><code>type = &quot;bridge&quot;</code></a></h2>
<p>This mode lets qemu create a tap interface and attach it to a bridge.</p>
<p>The <code>qemu-bridge-helper</code> binary needs to be setup with the proper
permissions. See the <code>host</code> module for that. qemu will be run
<em>without</em> <code>-sandbox on</code> in order for this contraption to work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shares"><a class="header" href="#shares">Shares</a></h1>
<p>In <code>microvm.shares</code> elements the <code>proto</code> field allows either of two
values:</p>
<ul>
<li>
<p><code>9p</code> (default) is built into many hypervisors, allowing you to
quickly share a directory tree</p>
</li>
<li>
<p><code>virtiofs</code> requires a separate virtiofsd service which is only
started as a prerequisite when you start MicroVMs through a systemd
service that comes with the <code>microvm.nixosModules.host</code> module.</p>
<p>Expect <code>virtiofs</code> to yield better performance over <code>9p</code>.</p>
</li>
</ul>
<h2 id="sharing-a-hosts-nixstore"><a class="header" href="#sharing-a-hosts-nixstore">Sharing a host's <code>/nix/store</code></a></h2>
<p>If a share with <code>source = &quot;/nix/store&quot;</code> is defined, size and build
time of the stage1 squashfs for <code>/dev/vda</code> will be reduced
drastically.</p>
<pre><code class="language-nix">microvm.shares = [ {
  tag = &quot;ro-store&quot;;
  source = &quot;/nix/store&quot;;
  mountPoint = &quot;/nix/.ro-store&quot;;
} ];
</code></pre>
<h2 id="writable-nixstore-overlay"><a class="header" href="#writable-nixstore-overlay">Writable <code>/nix/store</code> overlay</a></h2>
<p>An optional writable layer will be mounted if the path
<code>microvm.writableStoreOverlay</code> is set. Make sure that the path is
located on a writable filesystem.</p>
<p><strong>Caveat:</strong> The Linux overlay filesystem is very picky about the
filesystems that can be the upper (writable) layer. 9p/virtiofs shares
don't work currently, so resort to using a volume for that:</p>
<pre><code>{ config, ... }:
{
  microvm.writableStoreOverlay = &quot;/nix/.rw-store&quot;;

  microvm.volumes = [ {
    image = &quot;nix-store-overlay.img&quot;;
    mountPoint = config.microvm.writableStoreOverlay;
    size = 2048;
  } ];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microvm-output-options"><a class="header" href="#microvm-output-options">MicroVM output options</a></h1>
<p>Hypervisor runners are provided in the <code>config</code> generated by a
nixosSystem for you to use inside and outside your configuration.</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>microvm.runners</code></td><td>Attribute set of runner packages per known Hypervisor.</td></tr>
<tr><td><code>microvm.declaredRunner</code></td><td>Runner package selected according to <code>microvm.hypervisor</code></td></tr>
</tbody></table>
</div>
<p>The <code>microvm.runners</code> option provides a runner for each known
Hypervisor regardless of the <code>microvm.hypervisor</code> config setting. To
build <em>my-microvm</em> for Firecracker for example:</p>
<pre><code class="language-bash">nix run .#nixosConfigurations.my-microvm.config.microvm.runners.firecracker
</code></pre>
<p>The <code>microvm.declaredRunner</code> selects the hypervisor according to the
configured <code>microvm.hypervisor</code>.</p>
<pre><code class="language-bash">nix run .#nixosConfigurations.my-microvm.config.microvm.declaredRunner
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="microvmballoonmem"><a class="header" href="#microvmballoonmem">microvm.balloonMem</a></h2>
<p>Amount of balloon memory in megabytes</p>
<p>The way virtio-balloon works is that this is the memory size
that the host can request to be freed by the VM. Initial
booting of the VM allocates mem+balloonMem megabytes of RAM.</p>
<p><em>Type:</em>
signed integer</p>
<p><em>Default:</em>
<code>0</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmcrosvmextraargs"><a class="header" href="#microvmcrosvmextraargs">microvm.crosvm.extraArgs</a></h2>
<p>Extra arguments to pass to crosvm.</p>
<p><em>Type:</em>
list of string</p>
<p><em>Default:</em>
<code>[ ]</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmcrosvmpivotroot"><a class="header" href="#microvmcrosvmpivotroot">microvm.crosvm.pivotRoot</a></h2>
<p>A Hypervisor's sandbox directory</p>
<p><em>Type:</em>
null or string</p>
<p><em>Default:</em>
<code>null</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmdeclaredrunner"><a class="header" href="#microvmdeclaredrunner">microvm.declaredRunner</a></h2>
<p>Generated Hypervisor declared by <code>config.microvm.hypervisor</code></p>
<p><em>Type:</em>
package</p>
<p><em>Default:</em>
<code>&quot;config.microvm.runner.${config.microvm.hypervisor}&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmdevices"><a class="header" href="#microvmdevices">microvm.devices</a></h2>
<p>PCI/USB devices that are passed from the host to the MicroVM</p>
<p><em>Type:</em>
list of (submodule)</p>
<p><em>Default:</em>
<code>[ ]</code></p>
<p><em>Example:</em></p>
<pre><code>[ {
        bus = &quot;pci&quot;;
        path = &quot;0000:01:00.0&quot;;
      } {
        bus = &quot;pci&quot;;
        path = &quot;0000:01:01.0&quot;;
      } {
        # QEMU only
        bus = &quot;usb&quot;;
        path = &quot;vendorid=0xabcd,productid=0x0123&quot;;
      } ]
</code></pre>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmdevicesbus"><a class="header" href="#microvmdevicesbus">microvm.devices.*.bus</a></h2>
<p>Device is either on the <code>pci</code> or the <code>usb</code> bus</p>
<p><em>Type:</em>
one of “pci”, “usb”</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmdevicespath"><a class="header" href="#microvmdevicespath">microvm.devices.*.path</a></h2>
<p>Identification of the device on its bus</p>
<p><em>Type:</em>
string</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmforwardports"><a class="header" href="#microvmforwardports">microvm.forwardPorts</a></h2>
<p>When using the SLiRP user networking (default), this option allows to
forward ports to/from the host/guest.</p>
<p><warning><para>
If the NixOS firewall on the virtual machine is enabled, you also
have to open the guest ports to enable the traffic between host and
guest.
</para></warning></p>
<p><note><para>Currently QEMU supports only IPv4 forwarding.</para></note></p>
<p><em>Type:</em>
list of (submodule)</p>
<p><em>Default:</em>
<code>[ ]</code></p>
<p><em>Example:</em></p>
<pre><code>[ # forward local port 2222 -&gt; 22, to ssh into the VM
  { from = &quot;host&quot;; host.port = 2222; guest.port = 22; }

  # forward local port 80 -&gt; 10.0.2.10:80 in the VLAN
  { from = &quot;guest&quot;;
    guest.address = &quot;10.0.2.10&quot;; guest.port = 80;
    host.address = &quot;127.0.0.1&quot;; host.port = 80;
  }
]

</code></pre>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmforwardportsfrom"><a class="header" href="#microvmforwardportsfrom">microvm.forwardPorts.*.from</a></h2>
<p>Controls the direction in which the ports are mapped:</p>
<ul>
<li>
<p><literal>&quot;host&quot;</literal> means traffic from the host ports
is forwarded to the given guest port.</p>
</li>
<li>
<p><literal>&quot;guest&quot;</literal> means traffic from the guest ports
is forwarded to the given host port.</p>
</li>
</ul>
<p><em>Type:</em>
one of “host”, “guest”</p>
<p><em>Default:</em>
<code>&quot;host&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmforwardportsguestaddress"><a class="header" href="#microvmforwardportsguestaddress">microvm.forwardPorts.*.guest.address</a></h2>
<p>The IPv4 address on the guest VLAN.</p>
<p><em>Type:</em>
string</p>
<p><em>Default:</em>
<code>&quot;&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmforwardportsguestport"><a class="header" href="#microvmforwardportsguestport">microvm.forwardPorts.*.guest.port</a></h2>
<p>The guest port to be mapped.</p>
<p><em>Type:</em>
16 bit unsigned integer; between 0 and 65535 (both inclusive)</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmforwardportshostaddress"><a class="header" href="#microvmforwardportshostaddress">microvm.forwardPorts.*.host.address</a></h2>
<p>The IPv4 address of the host.</p>
<p><em>Type:</em>
string</p>
<p><em>Default:</em>
<code>&quot;&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmforwardportshostport"><a class="header" href="#microvmforwardportshostport">microvm.forwardPorts.*.host.port</a></h2>
<p>The host port to be mapped.</p>
<p><em>Type:</em>
16 bit unsigned integer; between 0 and 65535 (both inclusive)</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmforwardportsproto"><a class="header" href="#microvmforwardportsproto">microvm.forwardPorts.*.proto</a></h2>
<p>The protocol to forward.</p>
<p><em>Type:</em>
one of “tcp”, “udp”</p>
<p><em>Default:</em>
<code>&quot;tcp&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmgraphicsenable"><a class="header" href="#microvmgraphicsenable">microvm.graphics.enable</a></h2>
<p>Enable GUI support.</p>
<p>MicroVMs with graphics are intended for the interactive
use-case. They cannot be started through systemd jobs.</p>
<p>Support in Hypervisors:</p>
<ul>
<li><code>qemu</code> starts a Gtk window with the framebuffer of the virtio-gpu</li>
</ul>
<p><em>Type:</em>
boolean</p>
<p><em>Default:</em>
<code>false</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmgraphicssocket"><a class="header" href="#microvmgraphicssocket">microvm.graphics.socket</a></h2>
<p>Path of vhost-user socket</p>
<p><em>Type:</em>
string</p>
<p><em>Default:</em>
<code>&quot;$HOSTNAME-gpu.sock&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmguestenable"><a class="header" href="#microvmguestenable">microvm.guest.enable</a></h2>
<p>Whether to enable the microvm.nix guest module.</p>
<p><em>Type:</em>
boolean</p>
<p><em>Default:</em>
<code>true</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmhugepagemem"><a class="header" href="#microvmhugepagemem">microvm.hugepageMem</a></h2>
<p>Whether to use hugepages as memory backend.
(Currently only respected if using cloud-hypervisor)</p>
<p><em>Type:</em>
boolean</p>
<p><em>Default:</em>
<code>false</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmhypervisor"><a class="header" href="#microvmhypervisor">microvm.hypervisor</a></h2>
<p>Which hypervisor to use for this MicroVM</p>
<p>Choose one of: qemu, cloud-hypervisor, firecracker, crosvm, kvmtool</p>
<p><em>Type:</em>
one of “qemu”, “cloud-hypervisor”, “firecracker”, “crosvm”, “kvmtool”</p>
<p><em>Default:</em>
<code>&quot;qemu&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvminterfaces"><a class="header" href="#microvminterfaces">microvm.interfaces</a></h2>
<p>Network interfaces</p>
<p><em>Type:</em>
list of (submodule)</p>
<p><em>Default:</em>
<code>[ ]</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvminterfacesbridge"><a class="header" href="#microvminterfacesbridge">microvm.interfaces.*.bridge</a></h2>
<p>Attach network interface to host bridge interface for type = &quot;bridge&quot;</p>
<p><em>Type:</em>
null or string</p>
<p><em>Default:</em>
<code>null</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvminterfacesid"><a class="header" href="#microvminterfacesid">microvm.interfaces.*.id</a></h2>
<p>Interface name on the host</p>
<p><em>Type:</em>
string</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvminterfacesmac"><a class="header" href="#microvminterfacesmac">microvm.interfaces.*.mac</a></h2>
<p>MAC address of the guest's network interface</p>
<p><em>Type:</em>
string</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvminterfacesmacvtaplink"><a class="header" href="#microvminterfacesmacvtaplink">microvm.interfaces.*.macvtap.link</a></h2>
<p>Attach network interface to host interface for type = &quot;macvlan&quot;</p>
<p><em>Type:</em>
string</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvminterfacesmacvtapmode"><a class="header" href="#microvminterfacesmacvtapmode">microvm.interfaces.*.macvtap.mode</a></h2>
<p>The MACVLAN mode to use</p>
<p><em>Type:</em>
null or one of “private”, “vepa”, “bridge”, “passthru”, “source”</p>
<p><em>Default:</em>
<code>null</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvminterfacestype"><a class="header" href="#microvminterfacestype">microvm.interfaces.*.type</a></h2>
<p>Interface type</p>
<p><em>Type:</em>
one of “user”, “tap”, “macvtap”, “bridge”</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmkernelparams"><a class="header" href="#microvmkernelparams">microvm.kernelParams</a></h2>
<p>Includes boot.kernelParams but doesn't end up in toplevel, thereby allowing references to toplevel</p>
<p><em>Type:</em>
list of string</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmmem"><a class="header" href="#microvmmem">microvm.mem</a></h2>
<p>Amount of RAM in megabytes</p>
<p><em>Type:</em>
signed integer</p>
<p><em>Default:</em>
<code>512</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmprestart"><a class="header" href="#microvmprestart">microvm.preStart</a></h2>
<p>Commands to run before starting the hypervisor</p>
<p><em>Type:</em>
strings concatenated with “\n”</p>
<p><em>Default:</em>
<code>&quot;&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmqemubiosenable"><a class="header" href="#microvmqemubiosenable">microvm.qemu.bios.enable</a></h2>
<p>Enable BIOS argument to qemu.</p>
<p><em>Type:</em>
boolean</p>
<p><em>Default:</em>
<code>true</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmqemubiospath"><a class="header" href="#microvmqemubiospath">microvm.qemu.bios.path</a></h2>
<p>BIOS binary path</p>
<p><em>Type:</em>
path</p>
<p><em>Default:</em>
<code>&quot;/nix/store/7s3z1kn0vggxjylvxm65lzz55lj9ixwk-qboot-unstable-2020-04-23/bios.bin&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmqemuextraargs"><a class="header" href="#microvmqemuextraargs">microvm.qemu.extraArgs</a></h2>
<p>Extra arguments to pass to qemu.</p>
<p><em>Type:</em>
list of string</p>
<p><em>Default:</em>
<code>[ ]</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmrunner"><a class="header" href="#microvmrunner">microvm.runner</a></h2>
<p>Generated Hypervisor runner for this NixOS</p>
<p><em>Type:</em>
attribute set of package</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmshares"><a class="header" href="#microvmshares">microvm.shares</a></h2>
<p>Shared directory trees</p>
<p><em>Type:</em>
list of (submodule)</p>
<p><em>Default:</em>
<code>[ ]</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmsharesmountpoint"><a class="header" href="#microvmsharesmountpoint">microvm.shares.*.mountPoint</a></h2>
<p>Where to mount the share inside the container</p>
<p><em>Type:</em>
path</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmsharesproto"><a class="header" href="#microvmsharesproto">microvm.shares.*.proto</a></h2>
<p>Protocol for this share</p>
<p><em>Type:</em>
one of “9p”, “virtiofs”</p>
<p><em>Default:</em>
<code>&quot;9p&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmsharessocket"><a class="header" href="#microvmsharessocket">microvm.shares.*.socket</a></h2>
<p>Socket for communication with virtiofs daemon</p>
<p><em>Type:</em>
null or string</p>
<p><em>Default:</em>
<code>null</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmsharessource"><a class="header" href="#microvmsharessource">microvm.shares.*.source</a></h2>
<p>Path to shared directory tree</p>
<p><em>Type:</em>
path</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmsharestag"><a class="header" href="#microvmsharestag">microvm.shares.*.tag</a></h2>
<p>Unique virtiofs daemon tag</p>
<p><em>Type:</em>
string</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmsocket"><a class="header" href="#microvmsocket">microvm.socket</a></h2>
<p>Hypervisor control socket path</p>
<p><em>Type:</em>
null or string</p>
<p><em>Default:</em>
<code>&quot;${hostName}.sock&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmstoreonbootdisk"><a class="header" href="#microvmstoreonbootdisk">microvm.storeOnBootDisk</a></h2>
<p>Whether to include the required /nix/store on the boot disk.</p>
<p><em>Type:</em>
boolean</p>
<p><em>Default:</em>
<code>true</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmuser"><a class="header" href="#microvmuser">microvm.user</a></h2>
<p>User to switch to when started as root</p>
<p><em>Type:</em>
null or string</p>
<p><em>Default:</em>
<code>null</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmvcpu"><a class="header" href="#microvmvcpu">microvm.vcpu</a></h2>
<p>Number of virtual CPU cores</p>
<p><em>Type:</em>
signed integer</p>
<p><em>Default:</em>
<code>1</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmvolumes"><a class="header" href="#microvmvolumes">microvm.volumes</a></h2>
<p>Disk images</p>
<p><em>Type:</em>
list of (submodule)</p>
<p><em>Default:</em>
<code>[ ]</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmvolumesautocreate"><a class="header" href="#microvmvolumesautocreate">microvm.volumes.*.autoCreate</a></h2>
<p>Created image on host automatically before start?</p>
<p><em>Type:</em>
boolean</p>
<p><em>Default:</em>
<code>true</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmvolumesfstype"><a class="header" href="#microvmvolumesfstype">microvm.volumes.*.fsType</a></h2>
<p>File system for automatic creation and mounting</p>
<p><em>Type:</em>
string</p>
<p><em>Default:</em>
<code>&quot;ext4&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmvolumesimage"><a class="header" href="#microvmvolumesimage">microvm.volumes.*.image</a></h2>
<p>Path to disk image on the host</p>
<p><em>Type:</em>
string</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmvolumesmountpoint"><a class="header" href="#microvmvolumesmountpoint">microvm.volumes.*.mountPoint</a></h2>
<p>If and where to mount the volume inside the container</p>
<p><em>Type:</em>
null or path</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmvolumessize"><a class="header" href="#microvmvolumessize">microvm.volumes.*.size</a></h2>
<p>Volume size if created automatically</p>
<p><em>Type:</em>
signed integer</p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<h2 id="microvmwritablestoreoverlay"><a class="header" href="#microvmwritablestoreoverlay">microvm.writableStoreOverlay</a></h2>
<p>Path to the writable /nix/store overlay.</p>
<p>Make sure that the path points to a writable filesystem (tmpfs, volume, or share).</p>
<p><em>Type:</em>
null or string</p>
<p><em>Default:</em>
<code>null</code></p>
<p><em>Example:</em>
<code>&quot;/nix/.rw-store&quot;</code></p>
<p><em>Declared by:</em></p>
<ul>
<li><a href="file:///nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix">/nix/store/6w6hs4vm0w554zqjcs8snk9dvr3pcnfl-source/nixos-modules/microvm/options.nix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-microvm-as-a-package"><a class="header" href="#running-a-microvm-as-a-package">Running a MicroVM as a package</a></h1>
<p>Quickly running a MicroVM interactively is great for testing. You get
to interact with its console.</p>
<p>There are drawbacks: no preparation for TAP network interfaces is done
and no virtiofsd is started. These can be worked around by relying on
9p shares and using qemu's <code>host</code> network interfaces.</p>
<h2 id="immediately-running-a-nixosconfiguration"><a class="header" href="#immediately-running-a-nixosconfiguration">Immediately running a nixosConfiguration</a></h2>
<p>To run a <code>nixosConfiguration</code> off your Flake directly use:</p>
<pre><code class="language-bash">nix run .#nixosConfigurations.my-microvm.config.microvm.declaredRunner
</code></pre>
<h2 id="add-a-runner-package-to-your-flake"><a class="header" href="#add-a-runner-package-to-your-flake">Add a runner package to your Flake</a></h2>
<p>To add this runner permanently add a package like this to the outputs
of your <code>flake.nix</code>:</p>
<pre><code class="language-nix">packages.x86_64-linux.my-microvm = self.nixosConfigurations.my-microvm.config.declaredRunner;
</code></pre>
<p>You can then run the MicroVM with a simple <code>nix run .#my-microvm</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preparing-a-nixos-host-for-declarative-microvms"><a class="header" href="#preparing-a-nixos-host-for-declarative-microvms">Preparing a NixOS host for declarative MicroVMs</a></h1>
<p><strong>microvm.nix</strong> adds the following configuration for servers to
host MicroVMs reliably:</p>
<ul>
<li>a <code>/var/lib/microvms</code> state directory with one subdirectory per MicroVM</li>
<li>systemd services <code>microvm-tap-interfaces@</code> to setup TAP network interfaces</li>
<li>systemd services <code>microvm-virtiofsd@</code> to start virtiofsd instances</li>
<li>systemd services <code>microvm@</code> to start a MicroVM</li>
<li>configuration options to <a href="./declarative.html">declaratively build MicroVMs with the host
system</a></li>
<li>tools to <a href="./microvm-command.html">manage MicroVMs imperatively</a></li>
</ul>
<p>Prepare your host by including the microvm.nix <code>host</code> nixosModule:</p>
<pre><code class="language-nix"># Your server's flake.nix
{
  inputs.nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
  inputs.microvm.url = &quot;github:astro/microvm.nix&quot;;
  inputs.microvm.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;

  outputs = { self, nixpkgs, microvm }: {
    # Example nixosConfigurations entry
    nixosConfigurations.server1 = nixpkgs.lib.nixosSystem {
      system = &quot;x86_64-linux&quot;;
      modules = [
        # Include the microvm host module
        microvm.nixosModules.host
        # Add more modules here
        {
          networking.hostName = &quot;server1&quot;;

          # try to automatically start these MicroVMs on bootup
          microvm.autostart = [
            &quot;my-microvm&quot;
            &quot;your-microvm&quot;
            &quot;their-microvm&quot;
          ];
        }
      ];
    };
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-network-setup"><a class="header" href="#a-simple-network-setup">A simple network setup</a></h1>
<p>While your network setup is out of scope for the <strong>microvm.nix</strong>
flake, here is a simple guide for getting the MicroVMs on your server
networked.</p>
<p>Be aware that we dictate <code>systemd-networkd</code> on your server for maximum flexibility:</p>
<pre><code class="language-nix">networking.useNetworkd = true;
</code></pre>
<h2 id="a-bridge-to-link-tap-interfaces"><a class="header" href="#a-bridge-to-link-tap-interfaces">A bridge to link TAP interfaces</a></h2>
<p>To make your MicroVM reachable, use a TAP interface to get a virtual
Ethernet interface on the host. Although it is possible to assign
individual IP configuration to these individual interfaces, let us
avoid the additional configuration effort and create a bridge instead:</p>
<pre><code class="language-nix">systemd.network = {
  netdevs.&quot;10-microvm&quot;.netdevConfig = {
    Kind = &quot;bridge&quot;;
    Name = &quot;microvm&quot;;
  };
  networks.&quot;10-microvm&quot; = {
    matchConfig.Name = &quot;microvm&quot;;
    networkConfig = {
      DHCPServer = true;
      IPv6SendRA = true;
    };
    addresses = [ {
      addressConfig.Address = &quot;10.0.0.1/24&quot;;
    } {
      addressConfig.Address = &quot;fd12:3456:789a::1/64&quot;;
    } ];
    ipv6Prefixes = [ {
      ipv6PrefixConfig.Prefix = &quot;fd12:3456:789a::/64&quot;;
    } ];
  };
};
</code></pre>
<p>Better leave out the DHCP server and opt for static configuration
instead if you rely on stable IPv4 addresses.</p>
<p>Last, the TAP interfaces shall be attached to this central bridge. Make
sure your <code>matchConfig</code> matches just the interfaces you want!</p>
<pre><code class="language-nix">systemd.network = {
  networks.&quot;11-microvm&quot; = {
    matchConfig.Name = &quot;vm-*&quot;;
    networkConfig.Bridge = &quot;microvm&quot;;
  };
};
</code></pre>
<h2 id="provide-internet-access-with-nat"><a class="header" href="#provide-internet-access-with-nat">Provide Internet Access with NAT</a></h2>
<p>IPv4 addresses are exhausted. In some server environments you may not
get a dedicated /64 IPv6 prefix to route to your MicroVMs. <em>Network
Address Translation</em> to the rescue!</p>
<pre><code class="language-nix">networking.nat = {
  enable = true;
  enableIPv6 = true;
  externalInterface = &quot;eth0&quot;;
  internalInterfaces = [ &quot;microvm&quot; ];
};
</code></pre>
<p>Check out
<a href="https://search.nixos.org/options?channel=unstable&amp;show=networking.nat.forwardPorts&amp;query=networking.nat.forwardPorts"><code>networking.nat.forwardPorts</code></a>
to make your MicroVM's services available to networks outside your
host!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemd-services-on-a-microvm-host"><a class="header" href="#systemd-services-on-a-microvm-host">systemd services on a MicroVM host</a></h1>
<p>The <code>host</code> nixosModule provides a few systemd services for additional
bringup which is not available when running a MicroVM interactively
from a package.</p>
<h2 id="install-microvm-nameservice"><a class="header" href="#install-microvm-nameservice"><code>install-microvm-${name}.service</code></a></h2>
<p>Creates and prepares a subdirectory under <code>/var/lib/microvms</code> for
<a href="./declarative.html">declarative MicroVMs</a> according to the
<code>microvm.vms</code> option.</p>
<p>If the MicroVM subdirectory under <code>/var/lib/microvms</code> already exists,
<strong>and</strong> the MicroVM is configured to be built from a flake's
<code>nixosConfigurations</code>, this systemd unit will be skipped. The reason
for this behavior is that it is easier to update with the <a href="./microvm-command.html"><code>microvm</code>
command</a> instead of restarting all virtual
machines on a host when doing <code>nixos-rebuild switch</code>.</p>
<h2 id="microvm-tap-interfacesservice"><a class="header" href="#microvm-tap-interfacesservice"><code>microvm-tap-interfaces@.service</code></a></h2>
<p>Creates TAP virtual network interfaces for the user that will run MicroVMs.</p>
<h2 id="microvm-macvtap-interfacesservice"><a class="header" href="#microvm-macvtap-interfacesservice"><code>microvm-macvtap-interfaces@.service</code></a></h2>
<p>Creates MACVTAP virtual network interfaces for the user that will run MicroVMs.</p>
<h2 id="microvm-pci-devicesservice"><a class="header" href="#microvm-pci-devicesservice"><code>microvm-pci-devices@.service</code></a></h2>
<p>Prepares PCI devices for passthrough
(<a href="https://www.kernel.org/doc/html/latest/driver-api/vfio.html">VFIO</a>).</p>
<h2 id="microvm-virtiofsdservice"><a class="header" href="#microvm-virtiofsdservice"><code>microvm-virtiofsd@.service</code></a></h2>
<p>Starts a fleet of virtiofsd servers, one for each <code>virtiofs</code>
mountpoint in <code>microvm.shares</code>.</p>
<h2 id="microvmservice"><a class="header" href="#microvmservice"><code>microvm@.service</code></a></h2>
<p>Runs the actual MicroVM through
<code>/var/lib/microvms/%i/current/bin/microvm-run</code> where <code>%i</code> is the
MicroVM name.</p>
<h2 id="microvmstarget"><a class="header" href="#microvmstarget"><code>microvms.target</code></a></h2>
<p>Depends on the <code>microvm@.service</code> instance for all configured
<code>microvm.autostart</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declarative-microvms"><a class="header" href="#declarative-microvms">Declarative MicroVMs</a></h1>
<p>Provided your NixOS host <a href="./host.html">includes the host nixosModule</a>,
options are declared to build a MicroVM together with the host.
You can choose whether your MicroVMs should be managed in a fully-declarative
way, or whether your only want the initial deployment be declarative (with subsequent
imperative updates using the <a href="./microvm-command.html">microvm command</a>).</p>
<p>microvm.nix distinguishes between fully-declarative configurations
and declarative deployment by allowing you to specify either
a full <code>config</code> or just a <code>flake</code> respectively.</p>
<h2 id="fully-declarative"><a class="header" href="#fully-declarative">Fully declarative</a></h2>
<p>You can create fully declarative VMs by directly defining their
nixos system configuration in-place. This is very similar to how
nixos-containers work if you are familiar with those.</p>
<pre><code class="language-nix"># microvm refers to microvm.nixosModules
{ microvm, ... }: {
  imports = [ microvm.host ];
  microvm.vms = {
    my-microvm = {
      # The package set to use for the microvm. This also determines the microvm's architecture.
      # Defaults to the host system's package set if not given.
      pkgs = import nixpkgs { system = &quot;x86_64-linux&quot;; };

      # (Optional) A set of special arguments to be passed to the MicroVM's NixOS modules.
      #specialArgs = {};

      # The configuration for the MicroVM.
      # Multiple definitions will be merged as expected.
      config = {
        imports = [ microvm.microvm ];

        # It is highly recommended to share the host's nix-store
        # with the VMs to prevent building huge images.
        microvm.shares = [{
          source = &quot;/nix/store&quot;;
          mountPoint = &quot;/nix/.ro-store&quot;;
          tag = &quot;ro-store&quot;;
          proto = &quot;virtiofs&quot;;
        }];

        # This is necessary to import the host's nix-store database
        microvm.writableStoreOverlay = true;

        # Any other configuration for your MicroVM
        #...
      };
    };
  };
}
</code></pre>
<h2 id="declarative-deployment"><a class="header" href="#declarative-deployment">Declarative deployment</a></h2>
<p>Why <em>deployed</em>? The per-MicroVM subdirectory under <code>/var/lib/microvms</code>
is only created, if it did not exist before. This behavior is
intended to ensure existence of MicroVMs that are critical to
operation. To update them later you will have to use the <a href="./microvm-command.html">imperative microvm
command</a>.</p>
<pre><code class="language-nix">microvm.vms = {
  my-microvm = {
    # Host build-time reference to where the MicroVM NixOS is defined
    # under nixosConfigurations
    flake = self;
    # Specify from where to let `microvm -u` update later on
    updateFlake = &quot;git+file:///etc/nixos&quot;;
  };
};
</code></pre>
<p>Note that building MicroVMs with the host increases build time and
closure size of the host's system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imperative-microvm-management-with-the-microvm-command"><a class="header" href="#imperative-microvm-management-with-the-microvm-command">Imperative MicroVM management with the <code>microvm</code> command</a></h1>
<p>Compartmentalizing services in an infrastructure landscape allows us to
conduct maintenance individually and without affecting unrelated
MicroVMs. The <code>microvm</code> command helps with that.</p>
<h2 id="create-a-microvm"><a class="header" href="#create-a-microvm">Create a MicroVM</a></h2>
<p>You can specify this MicroVM's source flake with <code>-f</code>. If omitted, the
tool will assume <code>git+file:///etc/nixos</code>. The source flakeref will be
kept in <code>/var/lib/microvms/*/flake</code> for future updating the MicroVM.</p>
<pre><code class="language-bash">microvm -f git+https://... -c my-microvm
</code></pre>
<h3 id="enabling-microvm-autostart"><a class="header" href="#enabling-microvm-autostart">Enabling MicroVM autostart</a></h3>
<p>Extension of the host's systemd units must happen declaratively in the
host's NixOS configuration:</p>
<pre><code class="language-nix">microvm.autostart = [
  &quot;myvm1&quot;
  &quot;myvm2&quot;
  &quot;myvm3&quot;
];
</code></pre>
<h2 id="update-a-microvm"><a class="header" href="#update-a-microvm">Update a MicroVM</a></h2>
<p><em>Updating</em> does not refresh your packages but simply rebuilds the
MicroVM. Use <code>nix flake update</code> to get new package versions.</p>
<pre><code class="language-bash">microvm -u my-microvm
</code></pre>
<p>Until ways have been found to safely transfer the profile into the
target /nix/store, and subsequently activate it, you must restart the
MicroVM for the update to take effect.</p>
<p>Use the <code>-R</code> flag to automatically restart if an update was built.</p>
<h2 id="list-microvms"><a class="header" href="#list-microvms">List MicroVMs</a></h2>
<p>Listing your MicroVMs is as trivial as <code>ls -1 /var/lib/microvms</code></p>
<p>For more insight, the following command will read the current system
version of all MicroVMs and compare them to what the corresponding
flake evaluates. It is therefore quite slow to run, yet useful.</p>
<pre><code class="language-bash">microvm -l
</code></pre>
<h2 id="removing-microvms"><a class="header" href="#removing-microvms">Removing MicroVMs</a></h2>
<p>First, stop the MicroVM:</p>
<pre><code class="language-bash">systemctl stop microvm@$NAME
</code></pre>
<p>If you don't use absolute filesystem paths for sockets, volumes, or
shares, all MicroVM state is kept under <code>/var/lib/microvms/$NAME/</code>.
The <code>microvm@.serivce</code> systemd service template depends on existence
of this directory.</p>
<pre><code class="language-bash">rm -rf /var/lib/microvms/$NAME
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions-between-microvm-packages-and-the-host"><a class="header" href="#conventions-between-microvm-packages-and-the-host">Conventions between MicroVM packages and the host</a></h1>
<p>This section describes the interface that is used to run MicroVM
packages with the flake's <code>host</code> module. While the <strong>microvm.nix</strong>
flake was designed for single-server usage, you can build different
MicroVM deployments using the information on this page.</p>
<div class="table-wrapper"><table><thead><tr><th><code>nixosModule.microvm</code> option</th><th>MicroVM package file</th><th><code>nixosModules.host</code> systemd service</th><th>Description</th></tr></thead><tbody>
<tr><td><code>microvm.hypervisor</code></td><td><code>bin/microvm-run</code></td><td><code>microvm@.service</code></td><td>Start script for the main MicroVM process</td></tr>
<tr><td><code>microvm.hypervisor</code></td><td><code>bin/microvm-shutdown</code></td><td><code>microvm@.service</code></td><td>Script for graceful shutdown of the MicroVM (i.e. triggering the power button)</td></tr>
<tr><td><code>microvm.interfaces.*.id</code></td><td><code>share/microvm/tap-interfaces</code></td><td><code>microvm-tap-interfaces@.service</code></td><td>Names of the tap network interfaces to setup for the proper user</td></tr>
<tr><td><code>microvm.devices.*.path</code></td><td><code>share/microvm/pci-devices</code></td><td><code>microvm-pci-devices@.service</code></td><td>PCI devices that must be bound to the <strong>vfio-pci</strong> driver on the host</td></tr>
<tr><td><code>microvm.shares.*.source</code></td><td><code>share/microvm/virtiofs/${tag}/source</code></td><td><code>microvm-virtiofsd@.service</code></td><td>Source directory of a <strong>virtiofs</strong> instance by tag</td></tr>
<tr><td><code>microvm.shares.*.socket</code></td><td><code>share/microvm/virtiofs/${tag}/socket</code></td><td><code>microvm-virtiofsd@.service</code></td><td><strong>virtiofsd</strong> socket path by tag</td></tr>
<tr><td></td><td><code>share/microvm/system</code></td><td></td><td><code>config.system.build.toplevel</code> symlink, used for comparing versions when running <code>microvm -l</code></td></tr>
</tbody></table>
</div>
<h2 id="generating-custom-operating-system-hypervisor-packages"><a class="header" href="#generating-custom-operating-system-hypervisor-packages">Generating custom operating system hypervisor packages</a></h2>
<p>Because a microvm.nix runner package completely defines how to run the
Hypervisor, it is possible to define independent packages that
virtualize other operating systems than NixOS.</p>
<ul>
<li>
<p>Your NixOS configurations should export their runner package as
<code>config.microvm.declaredRunner</code> so that it can be picked up either
as <a href="declarative.html">declarative MicroVMs</a> or by <a href="microvm-command.html">the microvm
command</a>.</p>
</li>
<li>
<p>The runner package must have a file layout as described in the table
above.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>A few caveats. Contributions to eliminate those are welcome.</p>
<h2 id="can-i-support-the-development-and-maintenance-of-this-project"><a class="header" href="#can-i-support-the-development-and-maintenance-of-this-project">Can I support the development and maintenance of this project?</a></h2>
<p><a href="https://github.com/sponsors/astro">❤ Sponsor</a></p>
<h2 id="how-to-centralize-logging-with-journald"><a class="header" href="#how-to-centralize-logging-with-journald">How to centralize logging with journald?</a></h2>
<p>That is possible without even requiring a network transport by just
making the journals available to the host as a share. Because journald
identifies hosts by their <code>/etc/machine-id</code>, we propose to use static
content for that file. Add a NixOS module like the following to your
MicroVM configuration:</p>
<pre><code class="language-nix">environment.etc.&quot;machine-id&quot; = {
  mode = &quot;0644&quot;;
  text =
    # change this to suit your flake's interface
    self.lib.addresses.machineId.${config.networking.hostName} + &quot;\n&quot;;
};

microvm.shares = [ {
  # On the host
  source = &quot;/var/lib/microvms/${config.networking.hostName}/journal&quot;;
  # In the MicroVM
  mountPoint = &quot;/var/log/journal&quot;;
  tag = &quot;journal&quot;;
  proto = &quot;virtiofs&quot;;
  socket = &quot;journal.sock&quot;;
} ];
</code></pre>
<p>Last, make the MicroVM journals available to your host. The
<code>machine-id</code> must be available.</p>
<pre><code class="language-nix">systemd.tmpfiles.rules = map (vmHost:
  let
    machineId = self.lib.addresses.machineId.${vmHost};
  in
    # creates a symlink of each MicroVM's journal under the host's /var/log/journal
    &quot;L+ /var/log/journal/${machineId} - - - /var/lib/microvms/${vmHost}/journal/${machineId}&quot;
) (builtins.attrNames self.lib.addresses.machineId);
</code></pre>
<p>Once your MicroVM's journal data is visible in the
<code>/var/log/journal/$machineId/</code> directories, <code>journalctl</code> can pick it
up using the <code>-m</code>/<code>--merge</code> switch.</p>
<h2 id="can-i-build-with-hypervisors-from-the-hosts-nixpkgs-instead-of-the-microvms"><a class="header" href="#can-i-build-with-hypervisors-from-the-hosts-nixpkgs-instead-of-the-microvms">Can I build with hypervisors from the host's nixpkgs instead of the MicroVM's?</a></h2>
<p>Yes. This scenario is enabled through the flake's <code>lib.buildRunner</code>
function. See the <a href="https://github.com/astro/microvm.nix/blob/main/pkgs/build-microvm.nix"><code>nix run microvm#build-microvm</code></a>
script that you will need to customize to fit your deployment scenario.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
